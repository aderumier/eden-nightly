diff --git a/CMakeLists.txt b/CMakeLists.txt
index fe73f558c9..ef3fef7f6d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -601,6 +601,10 @@ if (ENABLE_QT)
         find_package(Qt6 REQUIRED COMPONENTS Multimedia)
     endif()
 
+    if (ENABLE_UPDATE_CHECKER)
+        find_package(Qt6 REQUIRED COMPONENTS Network)
+    endif()
+
     if (PLATFORM_LINUX OR PLATFORM_FREEBSD)
         # yes Qt, we get it
         set(QT_NO_PRIVATE_MODULE_WARNING ON)
diff --git a/src/android/app/src/main/java/org/yuzu/yuzu_emu/ui/main/MainActivity.kt b/src/android/app/src/main/java/org/yuzu/yuzu_emu/ui/main/MainActivity.kt
index 23716ac5a5..20305f5d35 100644
--- a/src/android/app/src/main/java/org/yuzu/yuzu_emu/ui/main/MainActivity.kt
+++ b/src/android/app/src/main/java/org/yuzu/yuzu_emu/ui/main/MainActivity.kt
@@ -180,19 +180,57 @@ class MainActivity : AppCompatActivity(), ThemeProvider {
 
     private fun checkForUpdates() {
         Thread {
-            val latestVersion = NativeLibrary.checkForUpdate()
-            if (latestVersion != null) {
+            val result = NativeLibrary.checkForUpdate()
+            if (result != null) {
+                val parts = result.split("|", limit = 2)
+                val version = parts[0]
+                val changelog = if (parts.size > 1) parts[1] else ""
+
                 runOnUiThread {
-                    showUpdateDialog(latestVersion)
+                    showUpdateDialog(version, changelog)
                 }
             }
         }.start()
     }
 
-    private fun showUpdateDialog(version: String) {
+    private fun showUpdateDialog(version: String, changelog: String) {
+        val scrollView = android.widget.ScrollView(this)
+
+        val textView = android.widget.TextView(this).apply {
+            val escapedLog = changelog
+            .replace("&", "&amp;")
+            .replace("<", "&lt;")
+            .replace(">", "&gt;")
+            .replace("\"", "&quot;")
+            .replace("'", "&#39;")
+
+            val formattedLog = escapedLog
+                .replace(Regex("\\[(.*?)\\]\\((.*?)\\)"), "<a href=\"$2\">$1</a>")
+                .replace(Regex("\\*\\*(.*?)\\*\\*"), "<b>$1</b>")
+                .replace(Regex("`(.*?)`"), "<font color='#FF4081'><tt>$1</tt></font>")
+                .replace("- Merged commit:", "â€¢ <b>Merged commit:</b>")
+                .replace("\n", "<br>")
+                .replace(Regex("^<br>+"), "")
+
+            val description = getString(R.string.update_available_description, version)
+            val fullContent = "<b>$description</b><br><br><b>Changelog:</b><br>$formattedLog"
+
+            text = android.text.Html.fromHtml(fullContent, android.text.Html.FROM_HTML_MODE_COMPACT)
+
+            movementMethod = android.text.method.LinkMovementMethod.getInstance()
+
+            linksClickable = true
+
+            val padding = (16 * resources.displayMetrics.density).toInt()
+            setPadding(padding, padding, padding, padding)
+            textSize = 14f
+        }
+
+        scrollView.addView(textView)
+
         MaterialAlertDialogBuilder(this)
             .setTitle(R.string.update_available)
-            .setMessage(getString(R.string.update_available_description, version))
+            .setView(scrollView)
             .setPositiveButton(android.R.string.ok) { _, _ ->
                 downloadAndInstallUpdate(version)
             }
diff --git a/src/android/app/src/main/jni/native.cpp b/src/android/app/src/main/jni/native.cpp
index 5746659b68..aaf5e1350e 100644
--- a/src/android/app/src/main/jni/native.cpp
+++ b/src/android/app/src/main/jni/native.cpp
@@ -1615,11 +1615,12 @@ JNIEXPORT jstring JNICALL Java_org_yuzu_yuzu_1emu_NativeLibrary_checkForUpdate(
                                 (strstr(Common::g_build_version, "alpha") != nullptr) ||
                                 (strstr(Common::g_build_version, "beta") != nullptr) ||
                                 (strstr(Common::g_build_version, "rc") != nullptr));
-    const std::optional<std::string> latest_release_tag =
+    const std::optional<UpdateChecker::ReleaseInfo> latest_release =
         UpdateChecker::GetLatestRelease(is_prerelease);
 
-    if (latest_release_tag && latest_release_tag.value() != Common::g_build_version) {
-        return env->NewStringUTF(latest_release_tag.value().c_str());
+    if (latest_release && latest_release->tag_name != Common::g_build_version) {
+        std::string result = latest_release->tag_name + "|" + latest_release->body;
+        return env->NewStringUTF(result.c_str());
     }
     return nullptr;
 }
diff --git a/src/frontend_common/CMakeLists.txt b/src/frontend_common/CMakeLists.txt
index b8a282b234..2170394298 100644
--- a/src/frontend_common/CMakeLists.txt
+++ b/src/frontend_common/CMakeLists.txt
@@ -17,6 +17,16 @@ add_library(frontend_common STATIC
 if (ENABLE_UPDATE_CHECKER)
     target_link_libraries(frontend_common PRIVATE httplib::httplib)
     target_link_libraries(frontend_common PRIVATE nlohmann_json::nlohmann_json)
+
+    if (ENABLE_QT)
+        target_link_libraries(frontend_common PRIVATE Qt6::Network Qt6::Core)
+        set_target_properties(frontend_common PROPERTIES AUTOMOC ON)
+
+        if (WIN32 AND NOT MSVC)
+        target_link_libraries(frontend_common PRIVATE brotlidec brotlicommon)
+        endif()
+    endif()
+
     target_sources(frontend_common PRIVATE
         update_checker.cpp
         update_checker.h)
diff --git a/src/frontend_common/update_checker.cpp b/src/frontend_common/update_checker.cpp
index 9a8143c788..71d0447ae0 100644
--- a/src/frontend_common/update_checker.cpp
+++ b/src/frontend_common/update_checker.cpp
@@ -19,6 +19,12 @@
 #include <nlohmann/json.hpp>
 #include <optional>
 #include <string>
+#include <algorithm>
+
+#ifndef ANDROID
+#include <QFile>
+#include <QNetworkRequest>
+#endif
 
 std::optional<std::string> UpdateChecker::GetResponse(std::string url, std::string path)
 {
@@ -78,7 +84,7 @@ std::optional<std::string> UpdateChecker::GetResponse(std::string url, std::stri
     }
 }
 
-std::optional<std::string> UpdateChecker::GetLatestRelease(bool include_prereleases) {
+std::optional<UpdateChecker::ReleaseInfo> UpdateChecker::GetLatestRelease(bool include_prereleases) {
     const auto update_check_url = std::string{Common::g_build_auto_update_api};
     std::string update_check_path = fmt::format("/repos/{}",
                                                 std::string{Common::g_build_auto_update_repo});
@@ -103,9 +109,12 @@ std::optional<std::string> UpdateChecker::GetLatestRelease(bool include_prerelea
             // If there is a newer tag, but that tag has no associated release, don't prompt the
             // user to update.
             if (!latest_tag_has_release)
-                return {};
+                return std::nullopt;
 
-            return latest_tag;
+            return ReleaseInfo{
+                latest_tag,
+                ""
+            };
         } else { // This is a stable release, only check for other stable releases.
             update_check_path += "/releases/latest";
             const auto response = UpdateChecker::GetResponse(update_check_url, update_check_path);
@@ -113,10 +122,54 @@ std::optional<std::string> UpdateChecker::GetLatestRelease(bool include_prerelea
             if (!response)
                 return {};
 
-            const std::string latest_tag = nlohmann::json::parse(response.value()).at("tag_name");
-            return latest_tag;
-        }
+            auto json = nlohmann::json::parse(response.value());
+            ReleaseInfo info;
+            info.tag_name = json.at("tag_name").get<std::string>();
+
+            std::string full_body = json.value("body", "");
+            std::string extracted_changelog = "";
+
+            const std::string start_marker = "## Changelog:";
+            const std::string end_marker = "## ";
+
+            size_t start_pos = full_body.find(start_marker);
+            if (start_pos != std::string::npos) {
+                size_t content_start = start_pos + start_marker.length();
+                size_t end_pos = full_body.find(end_marker, start_pos + start_marker.length());
+
+                if (end_pos != std::string::npos) {
+                    extracted_changelog = full_body.substr(content_start, end_pos - content_start);
+                } else {
+                    extracted_changelog = full_body.substr(content_start);
+                }
+            } else {
+                extracted_changelog = full_body;
+            }
+            extracted_changelog.erase(extracted_changelog.find_last_not_of(" \n\r\t") + 1);
+
+            info.body = extracted_changelog;
 
+            if (json.contains("assets") && json["assets"].is_array()) {
+                for (const auto& asset : json["assets"]) {
+                    std::string name = asset.value("name", "");
+                    std::string url = asset.value("browser_download_url", "");
+                    bool match = false;
+#ifdef _WIN32
+                    if (name.find("Windows") != std::string::npos) match = true;
+#elif defined(__apple__)
+                    if (name.find("MacOS") != std::string::npos) match = true;
+#elif defined(__FreeBSD__)
+                    if (name.find("FreeBSD") != std::string::npos) match = true;
+#else
+                    if (name.find("AppImage") != std::string::npos) match = true;
+#endif
+                    if (match) {
+                        info.assets.push_back({name, url});
+                    }
+                }
+            }
+            return info;
+        }
     } catch (nlohmann::detail::out_of_range &) {
         LOG_ERROR(Frontend,
                   "Parsing JSON response from {}{} failed during update check: "
@@ -133,3 +186,76 @@ std::optional<std::string> UpdateChecker::GetLatestRelease(bool include_prerelea
         return {};
     }
 }
+
+#ifndef ANDROID
+namespace UpdateChecker {
+UpdateChecker::UpdateDownloader::UpdateDownloader(QObject* parent)
+    : QObject(parent), manager(new QNetworkAccessManager(this)), file(nullptr), aborted(false) {}
+
+void UpdateDownloader::startDownload(const QUrl& url, const QString& savePath) {
+    file = new QFile(savePath);
+    if (!file->open(QIODevice::WriteOnly)) {
+        emit downloadFinished(false, file->errorString());
+        return;
+    }
+    QNetworkRequest request(url);
+    request.setAttribute(QNetworkRequest::RedirectPolicyAttribute, QNetworkRequest::NoLessSafeRedirectPolicy);
+    reply = manager->get(request);
+    connect(reply, &QNetworkReply::downloadProgress, this, &UpdateDownloader::onDownloadProgress);
+    connect(reply, &QNetworkReply::readyRead, this, &UpdateDownloader::onReadyRead);
+    connect(reply, &QNetworkReply::finished, this, &UpdateDownloader::onReplyFinished);
+}
+
+void UpdateDownloader::cancel() {
+    if (aborted) return;
+    aborted = true;
+
+    if (reply && reply->isRunning()) {
+        disconnect(reply, &QNetworkReply::downloadProgress, this, nullptr);
+        reply->abort();
+    }
+}
+
+void UpdateDownloader::onDownloadProgress(qint64 recv, qint64 total) { if (!aborted) emit progressChanged(recv, total); }
+void UpdateDownloader::onReadyRead() { if (!aborted && file && reply) file->write(reply->readAll()); }
+
+void UpdateDownloader::onReplyFinished() {
+    if (file && file->isOpen()) {
+        file->flush();
+        file->close();
+    }
+
+    bool is_canceled = (aborted || (reply && reply->error() == QNetworkReply::OperationCanceledError));
+    bool is_error = (reply && reply->error() != QNetworkReply::NoError && !is_canceled);
+
+    if (is_canceled) {
+        if (file) file->remove();
+        emit downloadFinished(false, tr("Download canceled."));
+    } else if (is_error) {
+        if (file) file->remove();
+        emit downloadFinished(false, reply->errorString());
+    } else {
+        emit downloadFinished(true, "");
+    }
+
+    if (reply) {
+        reply->deleteLater();
+        reply = nullptr;
+    }
+}
+
+UpdateDownloader::~UpdateDownloader() {
+    if (reply) {
+        reply->abort();
+    }
+
+    if (file) {
+        if (file->isOpen()) {
+            file->close();
+        }
+        delete file;
+        file = nullptr;
+    }
+}
+} // namespace UpdateChecker
+#endif
diff --git a/src/frontend_common/update_checker.h b/src/frontend_common/update_checker.h
index 957843bee0..51b17fc333 100644
--- a/src/frontend_common/update_checker.h
+++ b/src/frontend_common/update_checker.h
@@ -9,8 +9,56 @@
 
 #include <optional>
 #include <string>
+#include <vector>
+
+#ifndef ANDROID
+#include <QObject>
+#include <QString>
+#include <QUrl>
+#include <QPointer>
+#include <QFile>
+#include <QtNetwork/QNetworkAccessManager>
+#include <QtNetwork/QNetworkReply>
+#endif
 
 namespace UpdateChecker {
+struct Asset {
+    std::string name;
+    std::string url;
+};
+struct ReleaseInfo {
+    std::string tag_name;
+    std::string body;
+    std::vector<Asset> assets;
+};
+
+#ifndef ANDROID
+class UpdateDownloader : public QObject {
+    Q_OBJECT
+public:
+    explicit UpdateDownloader(QObject* parent = nullptr);
+    ~UpdateDownloader() override;
+    void startDownload(const QUrl& url, const QString& savePath);
+    void cancel();
+
+signals:
+    void progressChanged(qint64 bytesReceived, qint64 bytesTotal);
+    void downloadFinished(bool success, const QString& errorMsg);
+
+private slots:
+    void onDownloadProgress(qint64 bytesReceived, qint64 bytesTotal);
+    void onReadyRead();
+    void onReplyFinished();
+
+private:
+    QNetworkAccessManager* manager;
+    QPointer<QNetworkReply> reply;
+    QFile* file;
+    bool aborted{false};
+};
+#endif
+
 std::optional<std::string> GetResponse(std::string url, std::string path);
-std::optional<std::string> GetLatestRelease(bool include_prereleases);
+std::optional<ReleaseInfo> GetLatestRelease(bool include_prereleases);
+
 } // namespace UpdateChecker
diff --git a/src/yuzu/CMakeLists.txt b/src/yuzu/CMakeLists.txt
index 87d4652b07..e919eafeb9 100644
--- a/src/yuzu/CMakeLists.txt
+++ b/src/yuzu/CMakeLists.txt
@@ -391,7 +391,7 @@ elseif(WIN32)
 endif()
 
 target_link_libraries(yuzu PRIVATE nlohmann_json::nlohmann_json)
-target_link_libraries(yuzu PRIVATE common core input_common frontend_common network video_core qt_common)
+target_link_libraries(yuzu PRIVATE common core input_common frontend_common network video_core qt_common QuaZip::QuaZip)
 target_link_libraries(yuzu PRIVATE Boost::headers glad Qt6::Widgets Qt6::Concurrent)
 target_link_libraries(yuzu PRIVATE ${PLATFORM_LIBRARIES} Threads::Threads)
 
diff --git a/src/yuzu/main_window.cpp b/src/yuzu/main_window.cpp
index 4aeecb9da7..e0e418b2e2 100644
--- a/src/yuzu/main_window.cpp
+++ b/src/yuzu/main_window.cpp
@@ -58,18 +58,26 @@
 #include <QCheckBox>
 #include <QClipboard>
 #include <QDesktopServices>
+#include <QDialog>
+#include <QDialogButtonBox>
 #include <QDir>
 #include <QFileDialog>
 #include <QFileInfo>
 #include <QGuiApplication>
 #include <QInputDialog>
+#include <QLabel>
+#include <QMessageBox>
+#include <QMimeData>
 #include <QPalette>
 #include <QProgressDialog>
+#include <QRegularExpression>
 #include <QScreen>
 #include <QShortcut>
+#include <QStandardPaths>
 #include <QStatusBar>
 #include <QtConcurrentRun>
-#include <QMimeData>
+#include <QTextBrowser>
+#include <QVBoxLayout>
 
 // Qt Common //
 #include "qt_common/config/uisettings.h"
@@ -83,6 +91,7 @@
 #include "qt_common/util/meta.h"
 #include "qt_common/util/content.h"
 #include "qt_common/util/fs.h"
+#include "JlCompress.h"
 
 // These are wrappers to avoid the calls to CreateDirectory and CreateFile because of the Windows
 // defines.
@@ -516,19 +525,27 @@ MainWindow::MainWindow(bool has_broken_vulkan)
 
 #ifdef ENABLE_UPDATE_CHECKER
     if (UISettings::values.check_for_updates) {
-        update_future = QtConcurrent::run([]() -> QString {
+        update_future = QtConcurrent::run([]() -> QStringList {
             const bool is_prerelease = ((strstr(Common::g_build_version, "pre-alpha") != NULL) ||
                                         (strstr(Common::g_build_version, "alpha") != NULL) ||
                                         (strstr(Common::g_build_version, "beta") != NULL) ||
                                         (strstr(Common::g_build_version, "rc") != NULL));
-            const std::optional<std::string> latest_release_tag =
+            const std::optional<UpdateChecker::ReleaseInfo> latest_release =
                 UpdateChecker::GetLatestRelease(is_prerelease);
-            if (latest_release_tag && latest_release_tag.value() != Common::g_build_version) {
-                return QString::fromStdString(latest_release_tag.value());
+            if (latest_release && latest_release->tag_name != Common::g_build_version) {
+                QStringList list;
+                list << QString::fromStdString(latest_release->tag_name);
+                list << QString::fromStdString(latest_release->body);
+
+                for (const auto& asset : latest_release->assets) {
+                    list << QString::fromStdString(asset.name);
+                    list << QString::fromStdString(asset.url);
+                }
+                return list;
             }
-            return QString{};
+            return QStringList();
         });
-        update_watcher.connect(&update_watcher, &QFutureWatcher<QString>::finished, this,
+        update_watcher.connect(&update_watcher, &QFutureWatcher<QStringList>::finished, this,
                                &MainWindow::OnEmulatorUpdateAvailable);
         update_watcher.setFuture(update_future);
     }
@@ -4022,24 +4039,153 @@ void MainWindow::OnCaptureScreenshot() {
 
 #ifdef ENABLE_UPDATE_CHECKER
 void MainWindow::OnEmulatorUpdateAvailable() {
-    QString version_string = update_future.result();
-    if (version_string.isEmpty())
-        return;
+    QStringList result = update_future.result();
+
+    if (result.size() < 2) return;
+
+    QString version_string = result[0];
+    QString changelog = result[1];
+
+    QStringList asset_names;
+    QMap<QString, QString> url_map;
+    for (int i = 2; i < result.size(); i += 2) {
+        asset_names << result[i];
+        url_map[result[i]] = result[i+1];
+    }
+
+    QDialog update_dialog(this);
+    update_dialog.setWindowTitle(tr("Update Available"));
+    update_dialog.setMinimumWidth(500);
+
+    QVBoxLayout* main_layout = new QVBoxLayout(&update_dialog);
+
+    QLabel* header_label = new QLabel(tr("New update detected: %1").arg(version_string), &update_dialog);
+    header_label->setStyleSheet(QStringLiteral("font-weight: bold; font-size: 14px;"));
+    main_layout->addWidget(header_label);
+
+    if (!changelog.isEmpty()) {
+        QString html_changelog = changelog.toHtmlEscaped();
+
+        html_changelog.replace(QStringLiteral("- Merged commit:"),
+                       QStringLiteral("&bull; <b>Merged commit:</b>"));
+
+        static QRegularExpression link_re(QStringLiteral(R"(\[(.*?)\]\((.*?)\))"));
+        html_changelog.replace(link_re, QStringLiteral(R"(<a href="\2">\1</a>)"));
+
+        static QRegularExpression bold_re(QStringLiteral(R"(\*\*(.*?)\*\*)"));
+        html_changelog.replace(bold_re, QStringLiteral(R"(<b>\1</b>)"));
+
+        static QRegularExpression code_re(QStringLiteral(R"(`(.*?)`)"));
+        html_changelog.replace(code_re, QStringLiteral(R"(<code>\1</code>)"));
+
+        html_changelog.replace(QStringLiteral("\n"), QStringLiteral("<br>"));
+
+        if (html_changelog.startsWith(QLatin1String("<br><br>"))) {
+            html_changelog.remove(0, 8);
+        }
+
+        QTextBrowser* log_view = new QTextBrowser(&update_dialog);
+
+        log_view->setHtml(tr("<b>Changelog:</b><br>%1").arg(html_changelog));
+        log_view->setReadOnly(true);
+
+        log_view->setOpenExternalLinks(true);
+        log_view->setTextInteractionFlags(Qt::TextBrowserInteraction);
+
+        log_view->setMinimumHeight(200);
+        log_view->setMaximumHeight(400);
+        main_layout->addWidget(log_view);
+    }
+
+    main_layout->addWidget(new QLabel(tr("Download now?"), &update_dialog));
+
+    QDialogButtonBox* button_box = new QDialogButtonBox(
+        QDialogButtonBox::Yes | QDialogButtonBox::No, &update_dialog);
+
+    connect(button_box, &QDialogButtonBox::accepted, &update_dialog, &QDialog::accept);
+    connect(button_box, &QDialogButtonBox::rejected, &update_dialog, &QDialog::reject);
 
-    QMessageBox update_prompt(this);
-    update_prompt.setWindowTitle(tr("Update Available"));
-    update_prompt.setIcon(QMessageBox::Information);
-    update_prompt.addButton(QMessageBox::Yes);
-    update_prompt.addButton(QMessageBox::Ignore);
-    update_prompt.setText(
-        tr("Download the %1 update?").arg(version_string));
-    update_prompt.exec();
-    if (update_prompt.button(QMessageBox::Yes) == update_prompt.clickedButton()) {
-        auto const full_url = fmt::format("{}/{}/releases/tag/",
+    main_layout->addWidget(button_box);
+
+    if (update_dialog.exec() == QDialog::Accepted) {
+        QString selected_url;
+        QString fileName;
+
+        if (asset_names.isEmpty()) {
+            auto const full_url = fmt::format("{}/{}/releases/tag/",
                                           std::string{Common::g_build_auto_update_website},
                                           std::string{Common::g_build_auto_update_repo}
                                           );
-        QDesktopServices::openUrl(QUrl(QString::fromStdString(full_url) + version_string));
+            QDesktopServices::openUrl(QUrl(QString::fromStdString(full_url) + version_string));
+            return;
+        } else if (asset_names.size() == 1) {
+            fileName = asset_names[0];
+            selected_url = url_map[fileName];
+        } else {
+            bool ok;
+            fileName = QInputDialog::getItem(this, tr("Select Build"),
+                                                 tr("Multiple builds found for your platform.\n"
+                                                    "Please select the one that matches your system:"),
+                                                 asset_names, 0, false, &ok);
+            if (!ok || fileName.isEmpty()) return;
+            selected_url = url_map[fileName];
+        }
+
+        QString save_dir;
+#ifdef _WIN32
+        save_dir = QCoreApplication::applicationDirPath();
+#else
+        save_dir = QStandardPaths::writableLocation(QStandardPaths::DownloadLocation);
+        if (save_dir.isEmpty()) {
+            save_dir = QDir::homePath();
+        }
+#endif
+        QString save_path = QDir(save_dir).filePath(fileName);
+
+        QProgressDialog* progress = new QProgressDialog(
+            tr("Downloading Update: %1").arg(fileName),
+            tr("Cancel"), 0, 100, this);
+
+        progress->setWindowModality(Qt::WindowModal);
+        progress->setMinimumDuration(0);
+        progress->show();
+
+        auto* downloader = new UpdateChecker::UpdateDownloader(this);
+
+        connect(downloader, &UpdateChecker::UpdateDownloader::progressChanged, this, [progress](qint64 r, qint64 t){
+            if (t > 0) {
+                progress->setValue(static_cast<int>((r * 100) / t));
+            }
+        });
+
+        connect(downloader, &UpdateChecker::UpdateDownloader::downloadFinished, this, [this, progress, save_path, downloader](bool success, QString msg){
+            progress->close();
+            if (success) {
+                if (save_path.endsWith(QLatin1String(".zip"), Qt::CaseInsensitive)) {
+                    QString extract_path = QCoreApplication::applicationDirPath();
+                    QStringList extractedFiles = JlCompress::extractDir(save_path, extract_path);
+
+                    if (!extractedFiles.isEmpty()) {
+                        QMessageBox::information(this, tr("Success"), tr("Update downloaded and extracted."));
+
+                        QFile::remove(save_path);
+                    } else {
+                        QMessageBox::warning(this, tr("Extraction Failed"), tr("Failed to extract the update package."));
+                    }
+                }
+                else {
+                    QMessageBox::information(this, tr("Success"), tr("Update downloaded to:\n%1").arg(save_path));
+                    QDesktopServices::openUrl(QUrl::fromLocalFile(QFileInfo(save_path).absolutePath()));
+                }
+            } else {
+                QMessageBox::warning(this, tr("Download Failed"), msg);
+            }
+            downloader->deleteLater();
+        });
+
+        connect(progress, &QProgressDialog::canceled, downloader, &UpdateChecker::UpdateDownloader::cancel);
+
+        downloader->startDownload(QUrl(selected_url), save_path);
     }
 }
 #endif
diff --git a/src/yuzu/main_window.h b/src/yuzu/main_window.h
index 76ad165551..abbf677299 100644
--- a/src/yuzu/main_window.h
+++ b/src/yuzu/main_window.h
@@ -471,8 +471,8 @@ private:
     std::shared_ptr<InputCommon::InputSubsystem> input_subsystem;
 
 #ifdef ENABLE_UPDATE_CHECKER
-    QFuture<QString> update_future;
-    QFutureWatcher<QString> update_watcher;
+    QFuture<QStringList> update_future;
+    QFutureWatcher<QStringList> update_watcher;
 #endif
 
     MultiplayerState* multiplayer_state = nullptr;
